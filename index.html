<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸­å›½è±¡æ£‹ v1.0.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 500px;
            padding: 10px 0;
            color: white;
        }
        .player-info {
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
        }
        .player-info.active {
            background: rgba(255,255,0,0.3);
            box-shadow: 0 0 10px rgba(255,255,0,0.5);
        }
        .player-info h3 {
            font-size: 16px;
            margin-bottom: 5px;
        }
        .player-info .pieces-left {
            font-size: 12px;
            opacity: 0.8;
        }
        .game-container {
            position: relative;
            background: #DEB887;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            padding: 15px;
        }
        #chessCanvas {
            display: block;
            border-radius: 3px;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .btn {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .btn:active {
            transform: translateY(0);
        }
        .info-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.3);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 90%;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-content h2 {
            color: #8B4513;
            margin-bottom: 15px;
            text-align: center;
        }
        .modal-content h3 {
            color: #A0522D;
            margin: 15px 0 10px;
            font-size: 16px;
        }
        .modal-content ul {
            text-align: left;
            margin: 10px 0;
            padding-left: 20px;
            color: #555;
            font-size: 14px;
        }
        .modal-content li {
            margin: 6px 0;
        }
        .move-history {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            max-height: 150px;
            overflow-y: auto;
            margin: 10px 0;
            font-size: 13px;
        }
        .move-item {
            padding: 3px 0;
            border-bottom: 1px solid #ddd;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        .game-over.show {
            display: block;
        }
        .game-over h2 {
            margin-bottom: 15px;
            font-size: 28px;
            color: #FFD700;
        }
        @media (max-width: 500px) {
            .header {
                max-width: 350px;
            }
            .player-info {
                padding: 8px 12px;
            }
            .player-info h3 {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <button class="info-btn" onclick="showInfo()">â„¹ï¸</button>
    
    <div class="header">
        <div class="player-info active" id="redInfo">
            <h3>ğŸ”´ çº¢æ–¹</h3>
            <div class="pieces-left">å‰©ä½™ï¼š<span id="redPieces">16</span></div>
        </div>
        <div class="player-info" id="blackInfo">
            <h3>âš« é»‘æ–¹</h3>
            <div class="pieces-left">å‰©ä½™ï¼š<span id="blackPieces">16</span></div>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="chessCanvas"></canvas>
        <div class="game-over" id="gameOver">
            <h2 id="winnerText">ğŸ‰ çº¢æ–¹è·èƒœï¼ğŸ‰</h2>
            <p>æ€»æ­¥æ•°ï¼š<span id="totalMoves">0</span></p>
            <button class="btn" style="margin-top: 15px;" onclick="restartGame()">å†æ¥ä¸€å±€</button>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" onclick="undoMove()">â†©ï¸ æ‚”æ£‹</button>
        <button class="btn" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
        <button class="btn" onclick="showInfo()">ğŸ“– è§„åˆ™è¯´æ˜</button>
    </div>
    
    <div class="modal" id="infoModal">
        <div class="modal-content">
            <h2>ğŸ® ä¸­å›½è±¡æ£‹</h2>
            <p style="text-align: center;"><strong>ç‰ˆæœ¬ï¼š</strong>v1.0.0 | <strong>æ›´æ–°æ—¶é—´ï¼š</strong>2026-02-27</p>
            
            <h3>ğŸ“– æ¸¸æˆè§„åˆ™</h3>
            <ul>
                <li>ç‚¹å‡»é€‰ä¸­æ£‹å­ï¼Œå†ç‚¹å‡»ç›®æ ‡ä½ç½®ç§»åŠ¨</li>
                <li>çº¢æ–¹å…ˆèµ°ï¼ŒåŒæ–¹è½®æµè¡Œæ£‹</li>
                <li>åƒæ‰å¯¹æ–¹"å°†/å¸…"å³è·èƒœ</li>
                <li>æ£‹å­ä¸èƒ½ç§»åŠ¨åˆ°å·±æ–¹æ£‹å­ä½ç½®</li>
            </ul>
            
            <h3>â™Ÿï¸ æ£‹å­èµ°æ³•</h3>
            <ul>
                <li><strong>å°†/å¸…</strong>ï¼šä¹å®«å†…ä¸Šä¸‹å·¦å³ä¸€æ ¼</li>
                <li><strong>å£«</strong>ï¼šä¹å®«å†…æ–œèµ°ä¸€æ ¼</li>
                <li><strong>è±¡/ç›¸</strong>ï¼šç”°å­—å¯¹è§’ï¼Œä¸èƒ½è¿‡æ²³</li>
                <li><strong>é©¬</strong>ï¼šæ—¥å­—å¯¹è§’ï¼Œæœ‰è¹©è„šé™åˆ¶</li>
                <li><strong>è½¦</strong>ï¼šç›´çº¿ä»»æ„æ ¼</li>
                <li><strong>ç‚®</strong>ï¼šç›´çº¿ä»»æ„æ ¼ï¼Œåƒå­éœ€éš”ä¸€å­</li>
                <li><strong>å…µ/å’</strong>ï¼šè¿‡æ²³å‰åªèƒ½å‰è¿›ï¼Œè¿‡æ²³åå¯æ¨ªèµ°</li>
            </ul>
            
            <h3>ğŸ¯ æ“ä½œæç¤º</h3>
            <ul>
                <li>ç»¿è‰²æ ‡è®°ï¼šå¯ç§»åŠ¨ä½ç½®</li>
                <li>çº¢è‰²æ ‡è®°ï¼šå¯åƒå­ä½ç½®</li>
                <li>é»„è‰²é«˜äº®ï¼šå½“å‰é€‰ä¸­æ£‹å­</li>
            </ul>
            
            <button class="btn" onclick="hideInfo()">å…³é—­</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('chessCanvas');
        const ctx = canvas.getContext('2d');
        
        // æ£‹ç›˜é…ç½®
        const config = {
            cellSize: 50,
            margin: 40,
            boardWidth: 9,
            boardHeight: 10
        };
        
        // è®¡ç®—ç”»å¸ƒå°ºå¯¸
        const boardPixelWidth = (config.boardWidth - 1) * config.cellSize + config.margin * 2;
        const boardPixelHeight = (config.boardHeight - 1) * config.cellSize + config.margin * 2;
        
        canvas.width = boardPixelWidth;
        canvas.height = boardPixelHeight;
        
        // å“åº”å¼è°ƒæ•´
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 500);
            const scale = maxWidth / boardPixelWidth;
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = maxWidth * (boardPixelHeight / boardPixelWidth) + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // æ£‹å­å®šä¹‰
        const pieceTypes = {
            'k': { red: 'å¸…', black: 'å°†' },
            'a': { red: 'ä»•', black: 'å£«' },
            'b': { red: 'ç›¸', black: 'è±¡' },
            'n': { red: 'é©¬', black: 'é©¬' },
            'r': { red: 'è½¦', black: 'è½¦' },
            'c': { red: 'ç‚®', black: 'ç‚®' },
            'p': { red: 'å…µ', black: 'å’' }
        };
        
        // åˆå§‹æ£‹ç›˜å¸ƒå±€
        const initialBoard = [
            ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'],
            [null, null, null, null, null, null, null, null, null],
            [null, 'c', null, null, null, null, null, 'c', null],
            ['p', null, 'p', null, 'p', null, 'p', null, 'p'],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            ['P', null, 'P', null, 'P', null, 'P', null, 'P'],
            [null, 'C', null, null, null, null, null, 'C', null],
            [null, null, null, null, null, null, null, null, null],
            ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R']
        ];
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            board: [],
            currentTurn: 'red',
            selectedPiece: null,
            validMoves: [],
            moveHistory: [],
            gameOver: false,
            redPieces: 16,
            blackPieces: 16
        };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState.board = JSON.parse(JSON.stringify(initialBoard));
            gameState.currentTurn = 'red';
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.moveHistory = [];
            gameState.gameOver = false;
            gameState.redPieces = 16;
            gameState.blackPieces = 16;
            updatePlayerInfo();
            drawBoard();
        }
        
        // æ›´æ–°ç©å®¶ä¿¡æ¯
        function updatePlayerInfo() {
            document.getElementById('redPieces').textContent = gameState.redPieces;
            document.getElementById('blackPieces').textContent = gameState.blackPieces;
            document.getElementById('redInfo').classList.toggle('active', gameState.currentTurn === 'red');
            document.getElementById('blackInfo').classList.toggle('active', gameState.currentTurn === 'black');
        }
        
        // ç»˜åˆ¶æ£‹ç›˜
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            
            // æ¨ªçº¿
            for (let i = 0; i < config.boardHeight; i++) {
                ctx.beginPath();
                ctx.moveTo(config.margin, config.margin + i * config.cellSize);
                ctx.lineTo(boardPixelWidth - config.margin, config.margin + i * config.cellSize);
                ctx.stroke();
            }
            
            // ç«–çº¿ï¼ˆä¸­é—´æ–­å¼€ï¼‰
            for (let i = 0; i < config.boardWidth; i++) {
                ctx.beginPath();
                ctx.moveTo(config.margin + i * config.cellSize, config.margin);
                ctx.lineTo(config.margin + i * config.cellSize, config.margin + 4 * config.cellSize);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(config.margin + i * config.cellSize, config.margin + 5 * config.cellSize);
                ctx.lineTo(config.margin + i * config.cellSize, boardPixelHeight - config.margin);
                ctx.stroke();
            }
            
            // ä¹å®«æ ¼æ–œçº¿
            ctx.beginPath();
            ctx.moveTo(config.margin + 3 * config.cellSize, config.margin);
            ctx.lineTo(config.margin + 5 * config.cellSize, config.margin + 2 * config.cellSize);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(config.margin + 5 * config.cellSize, config.margin);
            ctx.lineTo(config.margin + 3 * config.cellSize, config.margin + 2 * config.cellSize);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(config.margin + 3 * config.cellSize, config.margin + 7 * config.cellSize);
            ctx.lineTo(config.margin + 5 * config.cellSize, boardPixelHeight - config.margin);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(config.margin + 5 * config.cellSize, config.margin + 7 * config.cellSize);
            ctx.lineTo(config.margin + 3 * config.cellSize, boardPixelHeight - config.margin);
            ctx.stroke();
            
            // æ¥šæ²³æ±‰ç•Œ
            ctx.font = '24px Microsoft YaHei';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.save();
            ctx.translate(config.margin + 2 * config.cellSize, config.margin + 4.5 * config.cellSize);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('æ¥š æ²³', 0, -20);
            ctx.fillText('æ±‰ ç•Œ', 0, 20);
            ctx.restore();
            
            // ç»˜åˆ¶æœ‰æ•ˆç§»åŠ¨ä½ç½®
            gameState.validMoves.forEach(move => {
                const x = config.margin + move.x * config.cellSize;
                const y = config.margin + move.y * config.cellSize;
                
                if (gameState.board[move.y] && gameState.board[move.y][move.x]) {
                    // å¯åƒå­ä½ç½®ï¼ˆçº¢è‰²ï¼‰
                    ctx.beginPath();
                    ctx.arc(x, y, config.cellSize * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fill();
                } else {
                    // å¯ç§»åŠ¨ä½ç½®ï¼ˆç»¿è‰²ï¼‰
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.fill();
                }
            });
            
            // ç»˜åˆ¶æ£‹å­
            for (let y = 0; y < config.boardHeight; y++) {
                for (let x = 0; x < config.boardWidth; x++) {
                    const piece = gameState.board[y][x];
                    if (piece) {
                        drawPiece(x, y, piece);
                    }
                }
            }
            
            // é«˜äº®é€‰ä¸­çš„æ£‹å­
            if (gameState.selectedPiece) {
                const x = config.margin + gameState.selectedPiece.x * config.cellSize;
                const y = config.margin + gameState.selectedPiece.y * config.cellSize;
                
                ctx.beginPath();
                ctx.arc(x, y, config.cellSize * 0.45, 0, Math.PI * 2);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }
        
        // ç»˜åˆ¶å•ä¸ªæ£‹å­
        function drawPiece(x, y, pieceCode) {
            const isRed = pieceCode === pieceCode.toUpperCase();
            const type = pieceCode.toLowerCase();
            const text = pieceTypes[type][isRed ? 'red' : 'black'];
            
            const px = config.margin + x * config.cellSize;
            const py = config.margin + y * config.cellSize;
            
            // æ£‹å­èƒŒæ™¯
            ctx.beginPath();
            ctx.arc(px, py, config.cellSize * 0.42, 0, Math.PI * 2);
            ctx.fillStyle = '#F5DEB3';
            ctx.fill();
            
            // è¾¹æ¡†
            ctx.beginPath();
            ctx.arc(px, py, config.cellSize * 0.42, 0, Math.PI * 2);
            ctx.strokeStyle = isRed ? '#C00' : '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // å†…åœˆ
            ctx.beginPath();
            ctx.arc(px, py, config.cellSize * 0.35, 0, Math.PI * 2);
            ctx.strokeStyle = isRed ? '#C00' : '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // æ–‡å­—
            ctx.font = `bold ${config.cellSize * 0.5}px Microsoft YaHei`;
            ctx.fillStyle = isRed ? '#C00' : '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, px, py + config.cellSize * 0.05);
        }
        
        // è·å–æ£‹å­é¢œè‰²
        function getPieceColor(pieceCode) {
            return pieceCode === pieceCode.toUpperCase() ? 'red' : 'black';
        }
        
        // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦åˆæ³•
        function isValidMove(fromX, fromY, toX, toY, pieceCode) {
            const pieceType = pieceCode.toLowerCase();
            const color = getPieceColor(pieceCode);
            const targetPiece = gameState.board[toY][toX];
            
            // ä¸èƒ½åƒå·±æ–¹æ£‹å­
            if (targetPiece && getPieceColor(targetPiece) === color) {
                return false;
            }
            
            const dx = toX - fromX;
            const dy = toY - fromY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            switch (pieceType) {
                case 'k': // å°†/å¸…
                    if (toX < 3 || toX > 5 || toY < 0 || toY > 2) return false;
                    if (color === 'black') {
                        if (toY < 7 || toY > 9) return false;
                    }
                    return (absDx + absDy === 1);
                    
                case 'a': // å£«
                    if (toX < 3 || toX > 5 || toY < 0 || toY > 2) return false;
                    if (color === 'black') {
                        if (toY < 7 || toY > 9) return false;
                    }
                    return (absDx === 1 && absDy === 1);
                    
                case 'b': // è±¡/ç›¸
                    if (color === 'red' && toY < 5) return false;
                    if (color === 'black' && toY > 4) return false;
                    if (absDx !== 2 || absDy !== 2) return false;
                    // æ£€æŸ¥å¡è±¡çœ¼
                    if (gameState.board[fromY + dy/2][fromX + dx/2]) return false;
                    return true;
                    
                case 'n': // é©¬
                    if (!((absDx === 1 && absDy === 2) || (absDx === 2 && absDy === 1))) return false;
                    // æ£€æŸ¥è¹©é©¬è…¿
                    if (absDx === 2) {
                        if (gameState.board[fromY][fromX + dx/2]) return false;
                    } else {
                        if (gameState.board[fromY + dy/2][fromX]) return false;
                    }
                    return true;
                    
                case 'r': // è½¦
                    if (fromX !== toX && fromY !== toY) return false;
                    return countPiecesBetween(fromX, fromY, toX, toY) === 0;
                    
                case 'c': // ç‚®
                    if (fromX !== toX && fromY !== toY) return false;
                    const count = countPiecesBetween(fromX, fromY, toX, toY);
                    if (targetPiece) {
                        return count === 1; // åƒå­éœ€è¦éš”ä¸€ä¸ª
                    } else {
                        return count === 0; // ç§»åŠ¨ä¸èƒ½éš”å­
                    }
                    
                case 'p': // å…µ/å’
                    if (color === 'red') {
                        if (toY > fromY) return false; // ä¸èƒ½åé€€
                        if (fromY >= 5) {
                            // æœªè¿‡æ²³ï¼Œåªèƒ½å‰è¿›
                            return (dx === 0 && dy === -1);
                        } else {
                            // å·²è¿‡æ²³ï¼Œå¯ä»¥æ¨ªèµ°æˆ–å‰è¿›
                            return (absDx + absDy === 1 && dy <= 0);
                        }
                    } else {
                        if (toY < fromY) return false; // ä¸èƒ½åé€€
                        if (fromY <= 4) {
                            // æœªè¿‡æ²³ï¼Œåªèƒ½å‰è¿›
                            return (dx === 0 && dy === 1);
                        } else {
                            // å·²è¿‡æ²³ï¼Œå¯ä»¥æ¨ªèµ°æˆ–å‰è¿›
                            return (absDx + absDy === 1 && dy >= 0);
                        }
                    }
            }
            return false;
        }
        
        // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ£‹å­æ•°é‡
        function countPiecesBetween(x1, y1, x2, y2) {
            let count = 0;
            if (x1 === x2) {
                const min = Math.min(y1, y2);
                const max = Math.max(y1, y2);
                for (let y = min + 1; y < max; y++) {
                    if (gameState.board[y][x1]) count++;
                }
            } else {
                const min = Math.min(x1, x2);
                const max = Math.max(x1, x2);
                for (let x = min + 1; x < max; x++) {
                    if (gameState.board[y1][x]) count++;
                }
            }
            return count;
        }
        
        // è·å–æ‰€æœ‰åˆæ³•ç§»åŠ¨
        function getValidMoves(x, y) {
            const moves = [];
            const pieceCode = gameState.board[y][x];
            
            for (let ty = 0; ty < config.boardHeight; ty++) {
                for (let tx = 0; tx < config.boardWidth; tx++) {
                    if (isValidMove(x, y, tx, ty, pieceCode)) {
                        moves.push({ x: tx, y: ty });
                    }
                }
            }
            return moves;
        }
        
        // å¤„ç†ç‚¹å‡»
        canvas.addEventListener('click', (e) => {
            if (gameState.gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;
            
            const gridX = Math.round((clickX - config.margin) / config.cellSize);
            const gridY = Math.round((clickY - config.margin) / config.cellSize);
            
            if (gridX < 0 || gridX >= config.boardWidth || gridY < 0 || gridY >= config.boardHeight) {
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨ç‚¹å‡»èŒƒå›´å†…
            const pieceX = config.margin + gridX * config.cellSize;
            const pieceY = config.margin + gridY * config.cellSize;
            const distance = Math.sqrt((clickX - pieceX) ** 2 + (clickY - pieceY) ** 2);
            
            if (distance > config.cellSize * 0.45) {
                return;
            }
            
            handleGridClick(gridX, gridY);
        });
        
        // å¤„ç†ç½‘æ ¼ç‚¹å‡»
        function handleGridClick(x, y) {
            const clickedPiece = gameState.board[y][x];
            const isCurrentTurnPiece = clickedPiece && getPieceColor(clickedPiece) === gameState.currentTurn;
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯æœ‰æ•ˆç§»åŠ¨ä½ç½®
            const isValidMove = gameState.validMoves.some(m => m.x === x && m.y === y);
            
            if (isValidMove && gameState.selectedPiece) {
                // æ‰§è¡Œç§»åŠ¨
                executeMove(gameState.selectedPiece.x, gameState.selectedPiece.y, x, y);
            } else if (isCurrentTurnPiece) {
                // é€‰æ‹©æ£‹å­
                gameState.selectedPiece = { x, y };
                gameState.validMoves = getValidMoves(x, y);
                drawBoard();
            } else {
                // å–æ¶ˆé€‰æ‹©
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                drawBoard();
            }
        }
        
        // æ‰§è¡Œç§»åŠ¨
        function executeMove(fromX, fromY, toX, toY) {
            const piece = gameState.board[fromY][fromX];
            const target = gameState.board[toY][toX];
            
            // è®°å½•ç§»åŠ¨å†å²
            gameState.moveHistory.push({
                from: { x: fromX, y: fromY },
                to: { x: toX, y: toY },
                piece: piece,
                captured: target,
                turn: gameState.currentTurn
            });
            
            // æ›´æ–°æ£‹ç›˜
            gameState.board[toY][toX] = piece;
            gameState.board[fromY][fromX] = null;
            
            // æ›´æ–°æ£‹å­è®¡æ•°
            if (target) {
                if (getPieceColor(target) === 'red') {
                    gameState.redPieces--;
                } else {
                    gameState.blackPieces--;
                }
            }
            
            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
            if (target && target.toLowerCase() === 'k') {
                endGame(gameState.currentTurn);
                return;
            }
            
            // åˆ‡æ¢å›åˆ
            gameState.currentTurn = gameState.currentTurn === 'red' ? 'black' : 'red';
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            
            updatePlayerInfo();
            drawBoard();
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame(winner) {
            gameState.gameOver = true;
            const winnerText = winner === 'red' ? 'ğŸ‰ çº¢æ–¹è·èƒœï¼ğŸ‰' : 'ğŸ‰ é»‘æ–¹è·èƒœï¼ğŸ‰';
            document.getElementById('winnerText').textContent = winnerText;
            document.getElementById('totalMoves').textContent = gameState.moveHistory.length;
            document.getElementById('gameOver').classList.add('show');
        }
        
        // æ‚”æ£‹
        function undoMove() {
            if (gameState.moveHistory.length === 0 || gameState.gameOver) return;
            
            const lastMove = gameState.moveHistory.pop();
            
            // æ¢å¤æ£‹ç›˜
            gameState.board[lastMove.from.y][lastMove.from.x] = lastMove.piece;
            gameState.board[lastMove.to.y][lastMove.to.x] = lastMove.captured;
            
            // æ¢å¤æ£‹å­è®¡æ•°
            if (lastMove.captured) {
                if (getPieceColor(lastMove.captured) === 'red') {
                    gameState.redPieces++;
                } else {
                    gameState.blackPieces++;
                }
            }
            
            // æ¢å¤å›åˆ
            gameState.currentTurn = lastMove.turn;
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            
            updatePlayerInfo();
            drawBoard();
        }
        
        // é‡æ–°å¼€å§‹
        function restartGame() {
            document.getElementById('gameOver').classList.remove('show');
            initGame();
        }
        
        // ä¿¡æ¯æ˜¾ç¤º
        function showInfo() {
            document.getElementById('infoModal').classList.add('show');
        }
        
        function hideInfo() {
            document.getElementById('infoModal').classList.remove('show');
        }
        
        // å¯åŠ¨æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
